## 八、内部存储器

### 1、存储器

存储器由一定数量的单元构成，每个单元可以被唯一标识，每个单元都有存储一个值的能力

- 地址：单元的唯一标识符（采用二进制）
- 地址空间：可唯一标识的单元总数
- 寻址能力：存储在每个单元中的信息的位数
  - 大多数存储器都是字节寻址的，而执行科学计算的计算机通常是64位寻址的

存储器的层次结构

![image-20220105230902993](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105230902993.png)

### 2、半导体存储器

用半导体芯片作主存储器是目前的主流做法

#### 1）<font color='red'>位元</font>

- 半导体存储器的基本元件，用于存储1位数据

- 特性

  - 呈现两种稳态（或半稳态）：分别表示二进制的0和1
  - 他们能够至少被写入数据一次：用来设置状态
  - 它们能够被读取来获得状态信息

- 操作

  ![image-20220105231240530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105231240530.png)

#### 2）半导体存储器类型

|       存储器类型       |           种类           |       可擦除性       | 写机制 | 易失性 |
| :--------------------: | :----------------------: | :------------------: | :----: | :----: |
| 随机存取存储器（RAM）  |       读-写存储器        |   电可擦除，字节级   |   电   |  易失  |
|   只读存储器（ROM）    |        只读存储器        |         不可         |  掩膜  | 非易失 |
|   可编程ROM（PROM）    |        只读存储器        |         不可         |   电   | 非易失 |
|  可擦除PROM（EPROM）   | 主要进行读写操作的存储器 | 紫外线可擦除，芯片级 |   电   | 非易失 |
| 电可擦除PROM（EEPROM） | 主要进行读写操作的存储器 |   电可擦除，字节级   |   电   | 非易失 |
|       快闪存储器       | 主要进行读写操作的存储器 |    电可擦除，块级    |   电   | 非易失 |

### 3、随机存取存储器（RAM）

> Random-Access Memory

特性

- 可以简单快速地进行读写操作
- 易失的(Volatile)

类型

- 动态RAM（DRAM）：Dynamic RAM
- 静态RAM（SRAM）：Static RAM

#### 1）DRAM

在电容上用电容充电的方式存储数据

- 电容器中有无电荷在分别代表二进制的1与0

需要==周期地充电刷新==以维护数据存储

- 原因：电容器有漏电地自然趋势
- 由一个阈值来确定电荷是被解释为1还是0

#### 2）SRAM

使用传统触发器、逻辑门配置来存储二进制

- 使用与处理器相同的逻辑元件

==只要有电源，就可以一直维持数据==

#### 3）DRAM与SRAM对比

- 相同点
  - 易失的：两者都要求电源持续供电才能保持位值
- 不同点
  - DRAM比SRAM具有更加简单、更小的位元，但要求能支持刷新的电路
  - DRAM比SRAM密度更高，价格更低
  - SRAM通常比DRAM更快
  - DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高速缓存，DRAM用于主存

#### 4）高级的DRAM架构

问题

- 传统的DRAM芯片受到其内部架构和与处理器内存总线接口限制

类型

- 同步DRAM（Synchronous DRAM，SDRAM）
- 双速率SDRAM（Double-Data-Rate SDRAM，DDR SDRAM/DDR）

#### 5）SDRAM

传统DRAM是异步的

- 处理器向内存提供地址和控制信号，表示内存中特定单元的一组数据应该被读出或者写入DRAM中
- DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，处理器只能等待这段延迟，即存取时间
- 延时后，DRAM才写入或读取数据
- <font color='blue'>在CPU发出地址和控制信号之后，经过一段延迟时间，数据才读出或写入。在这段时间里，CPU不断采样DRAM的完成信号，在没有完成之前，CPU插入等待状态而不能做其他工作</font>

SDRAM与处理器的数据交互同步与外部的时钟信号，并且以处理器/存储器总线的最高速度运行，而不需要插入等待时间

由于SDRAM随系统时钟及时移动数据，CPU知道数据何时准备好，控制器可以完成其他工作

<font color='blue'>SDRAM的读写受系统时钟控制，因此与CPU之间采用同步方式交换数据。它将CPU或其他主设备发出的地址和控制信号锁存起来，经过几个确定的时钟周期后给出响应。因此，主设备在这段时间内可以安全地进行其他操作</font>

![image-20220105234245371](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220105234245371.png)

#### 6）DDR SDRAM

- 每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在下降沿，以实现一个时钟内传送两位数据的功能。

- DDR——>DDR2——>DDR3——>DDR4（技术的更新迭代升级）
  - 增加操作频率
  - 增加预取缓冲区（每次可以取几位到I/O缓冲区中）

![image-20220106000644491](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106000644491.png)

### 4、只读存储器

#### 1）只读存储器（ROM）

> Read-only memory

特性：

- 非易失：不要求供电来维持数据
- 可读，但不能写入新数据

应用

- 微程序设计，库子程序，系统程序，函数表

问题

- 无出错机会：如果有一位出错，整批的ROM芯片只能报废
- 用户无法写入数据：唯一的数据写入机会在出厂时完成

#### 2）可编程ROM（PROM）

> Programmable ROM

特性：

- 非易失
- 只能被写入一次
  - 写过程是用电信号完成
  - 需要特殊设备来完成写或“编程”过程
- 与ROM对比
  - PROM提供了灵活性和方便性
  - ROM在大批量生产邻域让具有吸引力

### 5、主要进行读操作存储器

> Read-Mostly Memory

特性：

- 非易失的
- 写操作与读操作相比，较为困难

应用：

- 读操作比写操作频繁的多的场景

类型

- EPROM
- EEPROM
- Flash memory

#### 1）光可擦除/可编程只读存储器（EPROM）

> Erasable programmable read-only memory

特性

- 光可擦除
  - 擦除：在写操作前将封装芯片暴露在紫外线下
  - 所有的存储单元都变回相同的初始状态
  - 每次擦除需要约20分钟
- 电写入

与PROM相比，EPROM更贵，但具有可多次改写的优点

#### 2）电可擦除/可编程只读存储器（EEPROM）

> Electrically erasable programmable read-only memory

特性

- 可以随时写入而不删除之前的内容
- 只更新寻址到一个或多个字节
- 写操作每字节需要几百微秒

与EPROM对比，EEPROM更贵，且密度低，支持小容量芯片

#### 3）快闪存储器

> Flash Memory

特性

- 电可擦除：与EEPROM相同，优于EPROM

- 擦除时间为几秒：优于EPROM，不如EEPROM

- 可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM

- 达到与EPROM相同的密度：优于EEPROM

价格功能介于EPROM和EEPROM之间

### 6、从位元到主存

#### 1）寻址单元

由若干相同地址的位元组成

寻址模式

- 字节：常用
- 字

#### 2）存储阵列

由大量寻址单元组成	

![image-20220106082323656](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106082323656.png)

#### 3）如何寻址

通过地址译码器

- n位译码器有2^n^种输出
- 任何时候只有一个输出为1，其他都是0

#### 4）如何刷新

<font color='blue'>DRAM芯片的存储阵列中所有的存储电容都必须周期性地充电，这一过程称为刷新。刷新可以采用“读出”的方式进行，根据读出内容对响应单元进行“重写”，即读后再生。刷新时，只需要行地址，芯片中一行的所有元素被选中并进行“读出”操作。对于上述的存储器，要2048次刷新操作就可以将整个存储器刷新一遍。</font>

- 集中式刷新
  - 停止读写，并刷新每一行
  - 刷新时无法读取内存，极大影响系统执行效率
- 分散式刷新
  - 在每个存储周期中，当读写操作完成时进行刷新
  - 会增加每个存储周期的时间
- 异步刷新
  - 每一行各自以64ms间隔刷新
  - 效率高：常用
  - <font color='red'>刷新周期为64ms意思是，某行刷新了之后要再过64ms再刷新该行，是同一行的两次刷新的间隔。相邻两行的刷新间隔为  刷新周期 / 行数</font>

#### 5）芯片

![image-20220106084035673](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106084035673.png)

> 大多都采用地址引脚复用技术，行地址和列地址通过相同的管脚分先后两次输入，这样地址引脚数就减少一半了

#### 6）模块组织

- 位扩展：地址线不变，数据线增加
  - 使用8块4K$\times$1bit的芯片组成4K$\times$8bit的存储器
- 字扩展：地址线增加，数据线不变
  - 使用4个16K$\times$8bit的芯片组成64$\times$8bit的存储器
- 字、位同时扩展：数据线和地址线都增加
  - 使用8个16$\times$4bit的芯片组成64K$\times$8bit的存储器

#### 7）主存

插槽

- 组合多个存储模块

内存条插槽就是存储器总线

![image-20220106085336225](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106085336225.png)

### 7、相关习题

![image-20220106094720447](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106094720447.png)

![image-20220106094747696](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106094747696.png)

![image-20220106094759175](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106094759175.png)

> 这里不要和地址线复用搞混了，这里的地址寄存器是存放完整地址的。

![image-20220106095010035](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106095010035.png)

## 九、高速缓冲存储器（Cache）

![image-20220106095055137](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106095055137.png)

> Cache的引入是为了缓解内存墙问题

### 1、基本思路

解决内存墙带来的CPU和主存协作问题

- 再使用主存之余，添加一块小而快的cache
- Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块
- Cache中存放的是主存中部分信息的副本

### 2、工作流程

- 检查（check）：当CPU试图访问主存中的某个字时，首先检查这个字是否在cache中
- 检查后有两种情况
  - 命中（Hit）：在cache中，将这个字传送到CPU
  - 未命中（Miss）：不在cache中，则将主存中这个字所在的块送入cache中，再从cache传送该字给CPU

![image-20220106095610247](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106095610247.png)

### 3、问题

#### 1）如何判断命中还是未命中？

- ==冯诺依曼体系的设计==
  - CPU通过位置对主存中的内容进行访问，不关心存储在其中的内容
- Cache通过标记（tags）来标识其内容在主存中的对应位置

#### 2）未命中，为什么不直接将字送入CPU？为什么读入一个块而不是一个字？

##### 程序访问的局部性原理

- 定义
  - 处理器频繁访问主存中相同位置或者相邻存储位置的现象
- 类型
  - 时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同位置的信息）
  - 空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据
    - 顺序局部性：当数据被线性排列和访问时，出现的空间局部性的一种特殊情况。例如：遍历一维数组的元素

##### 向Cache传送内容

利用“时间局部性”

- 将未命中的数据在返回给CPU的同时存放在Cache中，以便再次访问时命中

##### 传送块而不是传送字

利用“空间局部性”

- 将包含所访问的字的块存储到Cache中，以便在访问相邻数据时命中

#### 3）使用Cache后操作更多，为什么还节省时间？

##### 【==平均访问时间==】

假设p是命中率，T~C~是cache访问时间，T~M~是主存访问时间，使用Cache时的平均访问时间为
$$
T_{A}=p\times T_{C}+(1-p)\times (T_{C}+T_{M})
\\ = T_{C}+(1-p)\times T_{M}
$$
命中率p越大，T~C~越小，效果越好

如果想要满足T~A~<T~M~，必须满足 p > T~C~ / T~M~

难点：Cache的容量远小于主存容量，使得命中率很难保证

### 4、设计要素

#### （1）Cache容量

扩大Cache容量：

- 命中率p增加
- Cache的开销和访问时间T~C~也在增加

![image-20220106101534154](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106101534154.png)

#### （2）映射功能

##### 1）直接映射

- 原理：将主存中的每一个块映射到一个固定可用的Cache行

- 计算：假设i是Cache行号，j是主存器块号，C是Cache行号

​													i = j mod C

- 优点：简单、快速映射、快速检查

- 缺点：抖动现象（Trashing），如果一个程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断地被交换到Cache中，Cache命中率将会降低

- 适合大容量Cache

##### 2）关联映射

- 原理：一个主存块可以装入Cache任意一行
- 优点：避免抖动
- 缺点：实现复杂，Cache搜索代价很大，需要搜索每一行
- 适合容量较小地Cache

##### 3）组关联映射

- 原理：将Cache分成若干组，每一组包含相同数量的行，每个主存块被映射到==固定组的任意一行==
- 计算：假设s是Cache组号，j是主存块号，S是组数

​						s = j mod S

- K-路组关联映射，就是每组K行，K = C / S
- 优点和缺点：结合了直接映射和关联映射的缺点和优点
- 属于一种折中

##### 4）三种映射方式的比较

> 三种映射都可以看成是组关联映射
>
> 直接映射：组数=1，每组C行
>
> 关联映射：组数=C，每组1行

==关联度==：一个主存块映射到Cache中可能存放位置个数

- 直接映射：1
- 关联映射：C
- 组关联映射：K

**==关联度越低，命中率越低，判断是否命中时间越短，标记所占额外空间开销越小==**

#### （3）替换算法

- 一旦Cache行被占用，当新的数据块要装入Cache中，原先存放的数据块将会被替换掉

- 对于直接映射，每个数据块只有唯一对应的行可以放置，不存在替换策略，直接换

- 对于关联映射和组关联映射，数据块的位置有多个位置选择，需要替换算法来决定替换哪一个数据块

- **替换算法通过硬件来实现**

- > 都是建立在一定假设上的

##### 1）最近最少使用算法（LRU）

> Least Recently Used

- 假设：最近使用过的数据块更有可能会被再次使用
- 策略：替换掉在Cache中最长时间未被访问的数据块
- 实现：对于2路组关联映射
  - 每行包含一个USE位
  - 当同一组的某行被访问时，将其USE位设为1，同时将另一行的USE位设为0
  - 当将新的数据块读入该组时，替换掉USE位为0的行中的数据块

##### 2）先进先出算法（FIFO）

- 假设：最近由主存载入Cache的数据块更有可能被使用
- 策略：替换掉在Cache中停留时间最长的块
- 实现：时间片轮旋转法或环形缓冲技术
  - 每行包含一个标识位
  - 当同一组中的某行被替换时，将其标识位设为1，同时将其下一行的标识位设为0
    - 如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为0
  - 当将新的数据块读入该组时，替换掉标识位为0的行中的数据块

##### 3）最不经常使用算法（LFU）

- 假设：访问越越频繁的数据块越有可能被再次使用
- 策略：替换掉Cache中被访问次数最少的数据块
- 实现：为每一行设置计数器

##### 4）随机替换算法（Random）

- 假设：每个数据块被再次用到的可能性是相同的
- 策略：随机替换Cache中的数据块
- 实现：随机替换
- ==随机替换算法在性能上只稍逊色于其他替换算法==

#### （4）写策略

- 主存和Cache的一致性
  - 当Cache中的某个数据块被替换时，需要考虑该数据块是否被修改
  - 被修改了：在替换之前，要将修改后的数据块写回到主存的相应位置
  - 没修改：直接替换
- 策略：写直达（write through）、写回法（Write back）

##### 1）写直达

- 所有的写操作都同时对Cache和主存进行

- 优点：确保主存中的数据总是和Cache中一致，并且总是最新的
- 缺点：产生大量的主存访问，减慢写操作

##### 2）写回法

- 原理：
  - 先更新Cache中的数据，当Cache中的某个数据块被替换时，如果它被修改了，再写回主存
  - 利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改
- 优点：减少了访问主存的次数
- 缺点：部分主存数据不是最新的
  - I/O模块存取时可能无法获得最新的数据，为解决该问题会使得电路设计更加复杂且有可能带来性能瓶颈

#### （5）行大小

- 假设从行的大小为一个字开始，随着行大小的逐步增大，则Cache命中率会增加
  - 数据块中包含了更多周围的数据，每次会有更多数据作为一个块装入Cache中
  - 利用了空间局部性
- 当行大小变得较大后，继续增加行大小，则会导致Cache命中率下降
  - 当Cache容量一定的前提下，较大的行会导致Cache中的行数变少，导致装入Cache中的数据块的数量变少，进而造成数据块被频繁替换
  - 每个数据块中包含的数据在主存中位置变远，被使用的可能性下降

- 行大小与命中率之间的关系较为复杂

#### （6）Cache数目

##### 1）一级 vs 多级

- 一级
  - 将Cache与处理器置于统一芯片上（片内Cache）
  - 减少处理器在外部总线上的活动，从而减少了执行时间
- 多级
  - 当L1未命中时，减少处理器对总线上DRAM或ROM的访问
  - 使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2 cache结合到处理器芯片上
  - <font color='blue'>对于一级Cache，通常追求速度，而对于二级Cache，通常追求命中率。</font>
  - <font color='red'>全局缺失率和局部缺失率</font>：例如两级Cache，访存100次，L1 Cache 命中94次，剩下的6次，L2 Cache 命中5次，只有1次访问主存，则全局缺失率为1%，L1 Cache和L2 Cache的局部缺失率分别为6 / 100 = 6%和1 / 6 = 16.7%
  - <font color='red'>假设L1 cache的存取时间为T~C1~，L2 cache的存取时间为T~C2~，L1 cache 局部命中率为p~1~，全局命中率为p~2~，主存的存取时间为T~m~，则读操作的时间为T=T~C1~+(1-p~1~)T~C2~+(1-p~2~)T~m~</font>

##### 2）统一 vs 分立

- 统一
  - 更高的命中率，在获取指令和数据的负载之间自动进行平衡
  - 只需要设计和实现一个Cache
- 分立
  - 消除Cache在指令的取值/译码单元和执行单元之间的竞争，在任何基于指令流水线的设计中都是重要的。

## 十、外部存储器

![image-20220106145536830](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106145536830.png)

### 1、外部存储器

- 特性
  - 用于存储不经常使用的、数据量较大的信息
  - 非易失
- 类型
  - 磁盘存储器
  - 光存储器
  - 磁带
  - U盘，固态硬盘

### 2、磁盘存储器

#### （1）介绍

磁盘是由涂有可磁化材料和非磁化材料（基材）构成的圆形盘片

- 基材：铝、铝合金、玻璃...
- 玻璃基材的优势：
  - 改善磁膜表面的均匀性，提高磁盘的可靠性
  - 显著减少整体表面瑕疵，以帮助减少读写错误
  - 能够支持磁头较低的飞行高度
  - 更高的硬度，使磁盘转动时更加稳定
  - 更强的抗冲击力和抗损伤能力
- 类型：软盘、硬盘

#### （2）结构

- ==每个盘面表面有一个读写磁头==，所有磁头通过机械方式固定在一起，==同时移动==
- 任何时候，所有磁头都位于距离磁盘中心等距离的磁道上

![image-20220106150350507](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106150350507.png)

- 对盘片进行读写操作的装置叫做==磁头==
  - 磁头必须产生或感应足够大的电磁场，以便正确地读写
  - 磁头越窄，离盘片地距离就越近
  - 更高的数据密度需要更窄的磁头和更窄的磁道，这将导致更高的出错风险
  - 温彻斯特磁头
    - 磁头实际上使一个空气动力箔片，当磁头静止时，它轻轻地停留在盘片的表面上
    - 旋转圆盘时产生的空气压力足以使箔片上升到盘片表面上方

#### （3）读写机制

- 读写操作期间，磁头静止，盘片在下方旋转
- 磁头数量：
  - 单磁头：读写共用一个（软盘，早期硬盘）
  - 双磁头：使用一个单独的磁头（当代硬盘）
- 写入机制
  - 电流脉冲被发送到写入磁头
  - 变化的电流激发出磁场
  - 产生的词性图案被记录在下面的盘片表面上
  - 反转电流方向，则记录介质上的磁化方向也会反转
- 读取机制
  - 读取磁头是由一个部分屏蔽的磁阻(MR)敏感器组成，其电阻取决于在其下移动的介质的磁化方向
  - 电流通过MR敏感器时，通过电压信号检测其电阻变化
  - MR敏感器允许更高频率的操作，实现更高的存储密度和更快的操作速度

#### （4）数据组织

- 磁盘上的数据组织呈现为一组同心圆，称为==磁道==
- 数据以==扇区==的形式传输到磁盘或传出磁盘
  - 扇区默认大小为512B
- 相邻磁道之间有间隙，相邻的扇区之间也有间隙
- <font color='red'>磁道从外向里编址，最外面的为磁道0</font>

![image-20220106151559809](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106151559809.png)

- 扇区的划分
  - 恒定角速度
    - 增大记录在盘片区域上的信息位的间隔，使得磁盘能够以恒定的速度扫描信息
    - 优点：能以磁道号和扇区号直接寻址各个数据块
    - 缺点：磁盘存储容量受到了最内层磁道所能实现的最大记录密度限制
  - 多带式记录/多重区域记录
    - 将盘面划分为多个同心圆区域，每个区域中个磁道的扇区数量是相同的，距离中心较远的分区包含的扇区数多于距离中心较近的分区
    - 优点：提升存储容量
    - 缺点：需要复杂的电路
- 所有盘片上处于相同的相对位置的一组磁道被称为柱面

#### （5）格式化

- <font color='blue'>格式化后的实际容量只有数据区，未格式化的容量是包括了头空、ID域等信息。</font>
- 磁道必须有一些起始点和辨别每个扇区起点及其终点的方法
- 格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取的额外数据

#### （6）==I/O访问时间==

- 寻道时间：磁头定位到相应的磁道所花的时间
  - 初始启动时间，跨越若干磁道所用时间

- 旋转延迟：等待相应扇区的起始处到达磁头的时间
  - 通常是磁道旋转半周所需要的时间
- 传送时间：数据传输的时间

$$
T = \frac{b}{rN}
\\ T=传送时间
\\ b=传送的字节数
\\ N=每磁道的字节数
\\ r=旋转速率，转/秒
$$

- <font color='red'>平均访问时间</font>

$$
T_{a}=T_{s}+\frac{1}{2r}+\frac{b}{rN}
$$

- 当连续访问多个相邻磁道时
  - 对于每个磁道都要考虑旋转延迟
  - 通常只需要考虑第一个磁道的寻道时间，但是在明确知道跨越每个磁道需要的时间时需要考虑

#### （7）磁头寻道/磁头调度

- 目标：当有多个访问磁盘任务时，使得平均寻道时间最小

##### 1）先来先服务（FCFS）

- 优点：公平简单

- 缺点：如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性能上很差，寻道时间长

##### 2）最短寻道时间（SSTF）

- 优点：每次的寻道时间最短（局部最优），平均寻道时间缩短
- 可能产生饥饿（<font color='blue'>距离当前磁头较远的任务长时间得到服务</font>）现象，尤其是位于两端的磁道请求

##### 3）SCAN

- 总是朝着一个方向进行调度，==直到该方向的边缘==，然后改变方向
- 优点：性能好，平均寻道时间短，不会产生饥饿现象
- 缺点：对于每个位置磁道响应频率不平均

##### 4）C-SCAN

- 只有磁头朝某个方向移动时才会响应请求，==移动到边缘后立即返回起点==，返回途中不做任何处理
- 优点：与SCAN相比，响应频率平均
- 缺点：与SCAN相比，平均寻道时间更长

##### 5）LOOK

- 只要磁头移动方向上==不再有请求就立即改变方向==

##### 6）C-LOOK

- 只要磁头移动方向上不再有请求就立即==返回起点==

### 3、光存储器

![image-20220106160524530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106160524530.png)

### 4、相关习题

![image-20220106204308989](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106204308989.png)

![image-20220106204418405](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106204418405.png)

![image-20220106204432963](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106204432963.png)

## 十一、冗余磁盘阵列

- 基本思想
  - 将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量
  - 将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率
  - 采用**数据冗余**来进行错误恢复以提高系统可靠性

- 特性
  - 由一组物理磁盘驱动器组成，被视为单个的逻辑驱动器
  - 数据是分布在多个物理磁盘上
  - 冗余磁盘容量用于存储校验信息，保证磁盘万一损坏时能恢复数据

![image-20220106180442209](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106180442209.png)

### 1、RAID0

![image-20220106161936920](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106161936920.png)

- 数据以条带的形式在可用的磁盘上分布
- 不采用冗余来改善性能
- 用途
  - 高数据传输率
  - 高速响应I/O请求：两个I/O请求所需要的数据块可能在不同的磁盘上

### 2、RAID1

![image-20220106162111063](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106162111063.png)

- 采用了数据条带
- 采用简单备份所有数据的方法实现冗余
- 优点：
  - 高速响应I/O请求
  - 读请求可以由包含请求数据的两个对应磁盘中的某1个提供服务，可以选择寻道时间较小的那个
  - 写请求需要更新两个对应的条带：可以并行完成，但是速度受限于写入比较慢的磁盘
  - 单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单
- 缺点：贵
- 用途：系统存储软件、数据和其他关键文件的驱动器中
- 与RAID0相比
  - 如果有大批的读请求，则RAID1能实现高速的I/O速率，性能可以达到RAID的两倍
  - 如果大部分是写请求，那就没什么优势

### 3、RAID 01 vs RAID 10

![image-20220106162618158](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106162618158.png)

主要在容错方面有区别

- RAID01只能坏一个盘
- RAID10能坏两个盘

### 4、RAID2

![image-20220106163058994](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106163058994.png)

- 并行存取技术
- 目标
  - 所有磁盘都参与每个I/O请求的执行
- 特点
  - 各个驱动器的轴是同步旋转的，因此每个磁盘的每个磁头在任何时刻都位于同一个位置
  - 采用数据条带：条带非常小，经常只有一个字节或一个字
- 纠错
  - 对位于同一条带的各个数据盘上的数据位计算校验码，检验码存储在该条带中多个校验码盘的相应位置
- 访问
  - 读取：获取请求的数据和对应校验码
  - 写入：所有数据盘和校验盘都被访问
- 缺点
  - 冗余盘依然较多，价格昂贵
  - 适用于多磁盘易出错环境，对于单个磁盘和磁盘驱动器已经具备高可靠性的情况下==没有意义==，被弃用。

### 5、RAID3

![image-20220106164129328](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106164129328.png)

和RAID2基本相同，但是RAID3采用奇偶校验码

- 当某磁盘损坏时，可以用于重构数据

​			$b_{0}=P(b)\oplus b_{1}\oplus b_{2}\oplus b_{3}$

- 优点：能够获得非常高的数据传输率
- 缺点：一次只能执行一个I/O请求

### 6、RAID4

![image-20220106164322031](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106164322031.png)

- 采用独立存取技术
  - 每个磁盘成员的操作都是独立的，各个I/O请求能够并行处理
- 采用较大的数据条带
- 采用奇偶校验
- 性能
  - 修改数据要同时要修改校验盘$P'(B)=P(B)\oplus B_{0} \oplus B_{0}'$
  - 存在一个很大的问题:<font color='red'>每次写操作必须涉及到唯一的校验盘。</font>被弃用

### 7、RAID5

![image-20220106174435600](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106174435600.png)

- 在所有磁盘上都分布了奇偶校验条带

  - 避免潜在的I/O瓶颈问题
  - 但是还是有限制

- 访问时的”两读两写“（<font color='red'>最好的情况读同时（一次），写同时（一次）；最差的情况读两次，写两次</font>）

  ​		$P'(B)=P(B)\oplus B_{0}\oplus B_{0}'$

### 8、RAID50

- 性能比RAID5高，容量利用率更低

![image-20220106175635327](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106175635327.png)

### 9、RAID6

![image-20220106175737226](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106175737226.png)

- 采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中
- 优点
  - 提升数据可用性：只有在平均修复时间间隔内3个磁盘都出现了故障，才会造成数据丢失
- 缺点
  - 写损失：每次都要写两个校验块

![](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106180055489.png)

![image-20220106180146767](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106180146767.png)

![image-20220106180221295](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106180221295.png)

### 10、相关习题

![image-20220106203958462](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106203958462.png)

![image-20220106204100042](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106204100042.png)

![image-20220106204153865](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106204153865.png)

## 十二、虚拟存储器

### 1、操作系统的出现

> 一种控制应用程序运行和在计算机用户与计算机硬件之间提供接口的程序

- 是计算机使用起来更加方便
- 允许计算机系统的资源以有效的方式使用

![image-20220106180803281](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106180803281.png)

### 2、存储器管理

#### 如何将更多任务装入主存

- 增大主存容量
- 使用交换技术
  - 当主存中没有处于就绪的任务时，操作系统调入其他任务来执行
  - 分区和分页
- 虚拟存储器
  - 请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上
  - 虚拟地址

#### 分区方式

两大区域

- 系统区
- 用户区

##### 简单固定分区

![image-20220106181308788](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106181308788.png)

- 用户区划分成长度不等的固定长的分区
- 当一个任务调入主存，分配一个可用的、能容纳它的最小的分区
- 优点：简单
- 缺点：浪费主存空间

##### 可变长分区

![image-20220106181528782](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106181528782.png)

- 用户区按每个任务所需要的内存大小进行分配
- 优点：提高了主存利用率
- 缺点：时间越长，存储器中的碎片越多

#### 分页方式

- 基本思想
  - 把主存分成固定长度且比较小的存储块，称为**页框**，每个任务也被划分成固定长度的程序块，称为**页**
  - 把页装入页框中，且无需采用连续的页框来存放一个任务中所有的页
- 逻辑地址：指令中的地址
- 物理地址：实际的主存地址

### 3、虚拟存储器

- 基本思想
  - **请求分页**：**仅将当前需要的页面调入主存**
    - 通过硬件将逻辑地址换成物理地址
    - 未命中时在主存和硬盘之间交换信息
- 优点
  - 在不扩大物理内存的前提下，可以载入更多的任务
  - 编写程序时**不用考虑可用物理内存的状态**，程序员认为可以独享一个连续的、很大的内存
  - 可以在大于物理内存的逻辑地址空间中编程

![image-20220106183010023](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106183010023.png)

- 设计的一些问题
  - 页大小：8KB，4KB
  - 映射算法：全关联映射
  - 写策略：写回
  - 类型：分页式、分段式、段页式

<font color='red'>Cache比主存快100倍，主存比硬盘快100000多倍，不到万不得已不能访问硬盘</font>

### 4、分页式虚拟存储器

- 主存储器和虚拟地址空间都被划分成大小相等的页面

  - 虚拟页/逻辑页：虚拟地址空间的页面
  - 物理页/页框：主存中的页面

- #### 页表

  - 页表包含了所有虚拟页的信息

  - 保存在主存中

  - 虚拟地址=虚拟页号+页内偏移量

  - 根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址

    ​	虚拟页号+页内偏移量 —— 物理页号+页内偏移量

    ![image-20220106183648952](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106183648952.png)

- #### 快表（TLB）

  - 类似于Cache的功能
  - 页表的使用增加了主存的访问次数，为了减少，把页表中最活跃的几个页表项复制到高速缓存中
  - 后备转换缓存器（快表）：将页表项放入高速缓存中
    - 映射：关联映射，组关联映射
    - 替换：随机替换
  - 主存中的页表相对应叫”慢表“

- #### ==CPU访存过程==

![image-20220106184031345](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106184031345.png)

![image-20220106184046025](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106184046025.png)

![image-20220106203541724](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106203541724.png)

![image-20220106184224988](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106184224988.png)

### 5、分段式虚拟存储器

- 将程序和数据分成不同长度的段，将所需的段加载到主存中
- 虚拟地址=段号+段内偏移
- ![image-20220106184428636](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106184428636.png)

### 6、段页式虚拟存储器

![image-20220106184417476](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106184417476.png)

### 7、相关习题

![image-20220106203659295](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220106203659295.png)

